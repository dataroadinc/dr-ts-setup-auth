# Versioning

This project uses the `dr-ts-versioning` package for stateless versioning. This
system generates changelogs dynamically during CI/CD builds without committing
`CHANGELOG.md` to git.

## Overview

The versioning system is designed to be:

- **Stateless**: No version files are committed to git
- **CI/CD Friendly**: Changelogs are generated during builds
- **Conventional**: Uses conventional commits for automatic versioning
- **Dynamic**: Version information is computed from git history

## Available Commands

```bash
# Check current version
pnpm version:current

# Bump to next patch version
pnpm version:next

# Generate changelog and update version
pnpm version:release
```

## How It Works

### Version Detection

The system determines the current version by:

1. Looking for the latest git tag matching the pattern `v*.*.*`
2. If no tag exists, it defaults to `0.0.0`
3. The version is automatically updated in `package.json`

### Changelog Generation

Changelogs are generated by:

1. Analyzing git commits since the last version tag
2. Grouping commits by conventional commit types (feat, fix, docs, etc.)
3. Organizing changes by scope (project, types, etc.)
4. Including commit hashes and links to GitHub

### Version Bumping

- **`version:current`**: Updates `package.json` with the current version from
  git tags
- **`version:next`**: Bumps the patch version (e.g., `0.0.1` â†’ `0.0.2`)
- **`version:release`**: Generates changelog and updates to current version

## Git Tags

Version tags follow the semantic versioning format:

- `v0.0.1` - Initial release
- `v0.0.2` - Patch release
- `v0.1.0` - Minor release
- `v1.0.0` - Major release

## Conventional Commits

The system uses conventional commits for automatic categorization:

```
feat(scope): add new feature
fix(scope): fix a bug
docs(scope): update documentation
style(scope): formatting changes
refactor(scope): code refactoring
test(scope): add or update tests
chore(scope): maintenance tasks
```

## CI/CD Integration

In CI/CD pipelines:

1. The `CHANGELOG.md` file is generated during builds
2. It's included in the published package
3. The file is properly gitignored to avoid committing it
4. Version information is computed from git history

## Benefits

- **No Version Conflicts**: No manual version file management
- **Automatic Changelogs**: Generated from commit history
- **CI/CD Ready**: Works seamlessly with automated deployments
- **Conventional**: Follows industry standards
- **Stateless**: No version state in repository

## Example Workflow

```bash
# Make changes and commit with conventional commits
git commit -m "feat(auth): add OAuth client setup"

# Bump version for release
pnpm version:release

# The system will:
# 1. Generate CHANGELOG.md from commits since last tag
# 2. Update package.json with current version
# 3. Create git tag for the new version
```
